<!DOCTYPE html>
<html lang="en">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content=" Quicksort Divide and Conquer To introduce another tool into our algorithm toolbox, we can introduce Divide &amp; Conquer, a useful method to recursively solve problems. Just like we learned in recursion, we need to identify our base case. Then we divide our problem into smaller problems, until we eventually reach our base case.
We can use the example of a plot of land:
If we wanted to divide our land into perfectly even square boxes, making sure to use all available land with no land left out. How would you begin to figure this out?
" />
<meta name="keywords" content="homepage, blog, computerscience, algorithms, textbook" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="http://localhost:1313/notes/computer-science/textbooks/grokking-algorithms/grokking-algorithms---chapter-4/" />


    <title>
        
            Grokking Algorithms - Chapter 4 :: Mr. Pointing  â€” Computer Science Teacher
        
    </title>








<link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#000000">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
    <link rel="shortcut icon" href="/favicon.ico">
    <meta name="msapplication-TileColor" content="">



  <meta itemprop="name" content="Grokking Algorithms - Chapter 4">
  <meta itemprop="description" content="Quicksort Divide and Conquer To introduce another tool into our algorithm toolbox, we can introduce Divide &amp; Conquer, a useful method to recursively solve problems. Just like we learned in recursion, we need to identify our base case. Then we divide our problem into smaller problems, until we eventually reach our base case.
We can use the example of a plot of land:
If we wanted to divide our land into perfectly even square boxes, making sure to use all available land with no land left out. How would you begin to figure this out?">
  <meta itemprop="datePublished" content="2025-02-17T00:00:00+00:00">
  <meta itemprop="dateModified" content="2025-02-17T00:00:00+00:00">
  <meta itemprop="wordCount" content="739">
  <meta itemprop="image" content="http://localhost:1313/">
  <meta itemprop="keywords" content="Computerscience,Algorithms,Textbook">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="http://localhost:1313/">
  <meta name="twitter:title" content="Grokking Algorithms - Chapter 4">
  <meta name="twitter:description" content="Quicksort Divide and Conquer To introduce another tool into our algorithm toolbox, we can introduce Divide &amp; Conquer, a useful method to recursively solve problems. Just like we learned in recursion, we need to identify our base case. Then we divide our problem into smaller problems, until we eventually reach our base case.
We can use the example of a plot of land:
If we wanted to divide our land into perfectly even square boxes, making sure to use all available land with no land left out. How would you begin to figure this out?">



    <meta property="og:url" content="http://localhost:1313/notes/computer-science/textbooks/grokking-algorithms/grokking-algorithms---chapter-4/">
  <meta property="og:site_name" content="Mr. Pointing">
  <meta property="og:title" content="Grokking Algorithms - Chapter 4">
  <meta property="og:description" content="Quicksort Divide and Conquer To introduce another tool into our algorithm toolbox, we can introduce Divide &amp; Conquer, a useful method to recursively solve problems. Just like we learned in recursion, we need to identify our base case. Then we divide our problem into smaller problems, until we eventually reach our base case.
We can use the example of a plot of land:
If we wanted to divide our land into perfectly even square boxes, making sure to use all available land with no land left out. How would you begin to figure this out?">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:published_time" content="2025-02-17T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-02-17T00:00:00+00:00">
    <meta property="article:tag" content="Computerscience">
    <meta property="article:tag" content="Algorithms">
    <meta property="article:tag" content="Textbook">
    <meta property="og:image" content="http://localhost:1313/">






    <meta property="article:published_time" content="2025-02-17 00:00:00 &#43;0000 UTC" />









    



    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">

    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text ">
                mr. pointing</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="/about">About</a></li><li><a href="/notes">Notes</a></li><li><a href="/now">Now</a></li><li><a href="/posts">Posts</a></li><li><a href="/projects">Projects</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title"><a href="http://localhost:1313/notes/computer-science/textbooks/grokking-algorithms/grokking-algorithms---chapter-4/">Grokking Algorithms - Chapter 4</a></h2>

            
            
            

            <div class="post-content">
                <hr>
<h1 id="quicksort">Quicksort</h1>
<h2 id="divide-and-conquer">Divide and Conquer</h2>
<p>To introduce another tool into our algorithm toolbox, we can introduce <strong>Divide &amp; Conquer</strong>, a useful method to recursively solve problems. Just like we learned in recursion, we need to identify our base case. Then we <em>divide</em> our problem into smaller problems, until we eventually reach our base case.</p>
<p>We can use the example of a plot of land:</p>

    <img src="/images/plot_of_land_base.png"  alt="plot_of_land_base"  class="center"  style="border-radius: 8px;"  />


<p>If we wanted to divide our land into perfectly even square boxes, making sure to use all available land with no land left out. How would you begin to figure this out?</p>
<p>In D&amp;C&rsquo;s case, we should determine a base case. A good way to think about this if one side is twice another, you could do a nice even split, so that&rsquo;s our best case. If you try to make the most even boxes you can, this is what you end up with:</p>

    <img src="/images/pol_cut.png"  alt="pol_cut"  class="center"  style="border-radius: 8px;"  />


<p>Thankfully, our recursive case is here to help us out. The same algorithm we used to D&amp;C the first plot will be done to the remaining or leftover portion of land, in this case the 400x640 space. We continue to break down the portion until we are left with the an 80x160 portion, satisfying our best case and returning how large our square portions should be; 80x80!</p>
<p>D&amp;C can also be used for finding things like sum and maximum. Recursive functions don&rsquo;t rely or need variables; the stack is what keeps track of the values as you move through the recursive case.</p>
<h3 id="exercises">Exercises</h3>
<ol>
<li>Write out the code for a recursive sum function</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_nums</span>(nums):
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> nums <span style="color:#f92672">==</span> []:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> nums[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> sum_nums(nums[<span style="color:#ae81ff">1</span>:])
</span></span></code></pre></div><ol start="2">
<li>Write out the code for a recursive counter</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">count_nums</span>(nums):
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> nums <span style="color:#f92672">==</span> []:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> count_nums(nums[<span style="color:#ae81ff">1</span>:])
</span></span></code></pre></div><ol start="3">
<li>Write a recursive function to find the max number in a list</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">max_num</span>(nums):
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> len(nums) <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> nums[<span style="color:#ae81ff">0</span>] <span style="color:#66d9ef">if</span> nums[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&gt;</span> nums[<span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">else</span> nums[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>	sub_max <span style="color:#f92672">=</span> max_num(nums[<span style="color:#ae81ff">1</span>:])
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> nums[<span style="color:#ae81ff">0</span>] <span style="color:#66d9ef">if</span> nums[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&gt;</span> sub_max <span style="color:#66d9ef">else</span> sub_max
</span></span></code></pre></div><ol>
<li>For Binary Search, what is the best case and what is the recursive case?
<ul>
<li>Base Case: An array with 1 item: if it matches, great! If not, not in array</li>
<li>Recursive Case: Split the array in half, and search the remaining half</li>
</ul>
</li>
</ol>
<h2 id="quicksort-1">Quicksort</h2>
<p>Obviously, quicksort is a sorting algorithm. It uses Divide &amp; Conquer, hence when it was just introduced.</p>
<p>Right away, we identify our case case: arrays that don&rsquo;t need to be sorted! An array with 0 or 1 element.</p>
<p>For a list of elements, to perform D&amp;C, we have to choose a <em>pivot</em> point, or where we&rsquo;ll split our array. For now, we can just choose the first number in the array.</p>
<p>After the pivot is found, we separate the remaining list into two categories, numbers smaller and larger than our pivot. This is known as <em>partitioning</em>.</p>
<p>Technically, this only works when the items before and after are sorted, correct? Well, that becomes our recursive case.</p>
<p>The code looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">quicksort</span>(nums):  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(nums) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>:  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> nums  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:  
</span></span><span style="display:flex;"><span>        pivot <span style="color:#f92672">=</span> nums[<span style="color:#ae81ff">0</span>]  
</span></span><span style="display:flex;"><span>        less <span style="color:#f92672">=</span> [i <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> nums[<span style="color:#ae81ff">1</span>:] <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&lt;=</span> pivot]  
</span></span><span style="display:flex;"><span>        more <span style="color:#f92672">=</span> [i <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> nums[<span style="color:#ae81ff">1</span>:] <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&gt;</span> pivot]  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> quicksort(less) <span style="color:#f92672">+</span> [pivot] <span style="color:#f92672">+</span> quicksort(more)  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>print(quicksort([<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span> ,<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">5</span>]))
</span></span></code></pre></div><h2 id="revisiting-big-o-notation">Revisiting Big O Notation</h2>
<p>Quicksort is a unique algorithm due to it&rsquo;s speed and times depending on your choice of pivot. Usually, constants don&rsquo;t affect the run time, so we can ignore them. For quicksort, the average case is faster than quicksort even though they are both $O(n \log n)$.</p>
<p>In the worst case, the list is already sorted, and the pivot is the first number. You will have to move through the list of size $n$, $n$ times! Even in the worst situation, if you move the pivot to the middle, you make less recursive calls: $O(n)$ vs $O(\log n)$.</p>
<p>We touch all $n$ elements, every step of the way, taking $O(n)$ time. We have to account for that:</p>
<ul>
<li>Worst case, $O(n)$ with $O(n)$ steps = $O(n^2)$</li>
<li>Best case, $O(\log n)$ with $O(n)$ steps = $O(n \log n)$</li>
</ul>
<p>Quicksort is a fast sorting algorithm, and a great example of Divide &amp; Conquer.</p>
<h3 id="exercises-1">Exercises</h3>
<p>How long in Big O for each?</p>
<ol>
<li>Printing the value of each element in an array: $O(n)$</li>
<li>Doubling the value of each element: $O(n)$</li>
<li>Doubling the value of just the first element: $O(1)$</li>
<li>Creating a multiplication table with all the elements of an array: $O(n^2)$</li>
</ol>
<hr>
<p>Next:
<a href="http://localhost:1313/notes/computer-science/textbooks/grokking-algorithms/grokking-algorithms---chapter-5/">Chapter 5</a></p>

            </div>
        </article>

        <hr />

        <div class="post-info">
            
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg>

        <span class="tag"><a href="http://localhost:1313/tags/computerscience/">computerscience</a></span>
        <span class="tag"><a href="http://localhost:1313/tags/algorithms/">algorithms</a></span>
        <span class="tag"><a href="http://localhost:1313/tags/textbook/">textbook</a></span>
        
    </p>

            
  		</div>
    </main>

            </div>

            
                <footer class="footer">
    
    <div class="footer__inner">
        <div class="footer__content" style=>
            
            <a href="https://mrpointing.com" style="text-decoration: none;">Richard Pointing</a>
            <span><a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></span>
            
            
        </div>
    </div>
    
    
</footer>

            
        </div>

        



<script type="text/javascript" src="/bundle.min.e89fda0f29b95d33f6f4224dd9e5cf69d84aff3818be2b0d73e731689cc374261b016d17d46f8381962fb4a1577ba3017b1f23509d894f6e66431f988c00889e.js" integrity="sha512-6J/aDym5XTP29CJN2eXPadhK/zgYvisNc&#43;cxaJzDdCYbAW0X1G&#43;DgZYvtKFXe6MBex8jUJ2JT25mQx&#43;YjACIng=="></script>




    </body>
</html>
