<!doctype html><html lang=en><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="Modified: August 02 2024
The Role of Algorithms in Computing 1.1 Algorithms Algorithm: Any well defined computational procedure that takes some value, or set of values, as input and produces some value, or set of values, as output in a finite amount of time.
We often say algorithms help us solve computational problems.
We can define a sorting algorithm like so: Input: A sequence of n numbers, ${a_1, a_2, &amp;hellip; a_n}$ Output: A permutation (reordering) ${a_1,a_2,&amp;hellip;a_n}$ of the input sequence such that $a_1 &amp;lt;= a_2 &amp;lt;= ."><meta name=keywords content="homepage,blog,computerscience,algorithms,textbook"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=http://localhost:1313/posts/computer-science/introduction-to-algorithms/part-1/introduction-to-algorithms---chapter-1/><title>Introduction to Algorithms - Chapter 1 :: Mr. Pointing — Python Teacher
</title><link rel=stylesheet href=/main.9a8b2bfd3b57cf24918963cf5c8025ac2284e56ea037e60d10a5981ecfcc5055.css integrity="sha256-mosr/TtXzySRiWPPXIAlrCKE5W6gN+YNEKWYHs/MUFU="><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="Introduction to Algorithms - Chapter 1"><meta itemprop=description content="Modified: August 02 2024
The Role of Algorithms in Computing 1.1 Algorithms Algorithm: Any well defined computational procedure that takes some value, or set of values, as input and produces some value, or set of values, as output in a finite amount of time.
We often say algorithms help us solve computational problems.
We can define a sorting algorithm like so: Input: A sequence of n numbers, ${a_1, a_2, … a_n}$ Output: A permutation (reordering) ${a_1,a_2,…a_n}$ of the input sequence such that $a_1 <= a_2 <= ."><meta itemprop=datePublished content="2024-07-18T00:00:00+00:00"><meta itemprop=dateModified content="2024-07-18T00:00:00+00:00"><meta itemprop=wordCount content="1292"><meta itemprop=image content="http://localhost:1313/"><meta itemprop=keywords content="Computerscience,Algorithms,Textbook"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/"><meta name=twitter:title content="Introduction to Algorithms - Chapter 1"><meta name=twitter:description content="Modified: August 02 2024
The Role of Algorithms in Computing 1.1 Algorithms Algorithm: Any well defined computational procedure that takes some value, or set of values, as input and produces some value, or set of values, as output in a finite amount of time.
We often say algorithms help us solve computational problems.
We can define a sorting algorithm like so: Input: A sequence of n numbers, ${a_1, a_2, … a_n}$ Output: A permutation (reordering) ${a_1,a_2,…a_n}$ of the input sequence such that $a_1 <= a_2 <= ."><meta property="og:url" content="http://localhost:1313/posts/computer-science/introduction-to-algorithms/part-1/introduction-to-algorithms---chapter-1/"><meta property="og:site_name" content="Mr. Pointing"><meta property="og:title" content="Introduction to Algorithms - Chapter 1"><meta property="og:description" content="Modified: August 02 2024
The Role of Algorithms in Computing 1.1 Algorithms Algorithm: Any well defined computational procedure that takes some value, or set of values, as input and produces some value, or set of values, as output in a finite amount of time.
We often say algorithms help us solve computational problems.
We can define a sorting algorithm like so: Input: A sequence of n numbers, ${a_1, a_2, … a_n}$ Output: A permutation (reordering) ${a_1,a_2,…a_n}$ of the input sequence such that $a_1 <= a_2 <= ."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-18T00:00:00+00:00"><meta property="article:modified_time" content="2024-07-18T00:00:00+00:00"><meta property="article:tag" content="Computerscience"><meta property="article:tag" content="Algorithms"><meta property="article:tag" content="Textbook"><meta property="og:image" content="http://localhost:1313/"><meta property="article:published_time" content="2024-07-18 00:00:00 +0000 UTC"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>mr. pointing</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/about>About</a></li><li><a href=/posts>Posts</a></li></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
7 minutes</p></div><article><h1 class=post-title><a href=http://localhost:1313/posts/computer-science/introduction-to-algorithms/part-1/introduction-to-algorithms---chapter-1/>Introduction to Algorithms - Chapter 1</a></h1><div class=post-content><p>Modified: August 02 2024</p><hr><h2 id=the-role-of-algorithms-in-computing>The Role of Algorithms in Computing</h2><h2 id=11-algorithms>1.1 Algorithms</h2><p><strong>Algorithm:</strong> Any well defined computational procedure that takes some value, or set of values, as <em>input</em> and produces some value, or set of values, as <em>output</em> in a finite amount of time.</p><p>We often say algorithms help us solve computational problems.</p><p>We can define a sorting algorithm like so:
<strong>Input:</strong> A sequence of <em>n</em> numbers, ${a_1, a_2, &mldr; a_n}$
<strong>Output:</strong> A permutation (reordering) ${a<code>_1,a</code>_2,&mldr;a<code>_n}$ of the input sequence such that $a</code>_1 &lt;= a<code>_2 &lt;= ... &lt;= a</code>n$</p><p>If given (7, 3, 12, 1, 5), the correct sorting algorithm, would return (1, 3, 5, 7, 12).</p><p>The input sequence is called an <em>instance</em> of the sorting problem.</p><p>The <em>instance of a problem</em> is an input sequence needed to compute a solution to said problem.</p><p>Sorting is a fundamental concept in programming, considering how many times one is used as an intermediate step.</p><p>To that affect, different sorting algorithms are good at accomplishing different things.</p><p>We consider an algorithm for a computational problem as correct, if for every instance, it halts - or stops in a finite time and outputs the correct solution to the problem instance.</p><p>What kinds of problems are solved by algorithms?</p><ul><li>The Human Genome Project, identifying the unique 30,000 Human DNA genes, uses complex Algorithms, Dynamic Programming among them.</li><li>The internet, using algorithms to determine the best route to send data, and search engines find pages on most relevant information.</li><li>Electronic Commerce allows for exchange of goods and services; public-key cryptography and digital signature are based on numerical algorithms & number theory.</li></ul><p>We can look at specific problems:</p><ul><li>Shortest route to destination (Chapter 22)</li><li>Doctors using clustering algorithms for tumors (Chapter 33)</li><li>Compression (Chapter 15)</li></ul><p>Problems that can be solved with Algorithms have two common characteristics:</p><ol><li>They have lots of candidate solutions, most which don&rsquo;t solve the problem, and finding the best is hard.</li><li>They have practical applications</li></ol><p>A 7/23/24</p><p>Some problems are so complex, no algorithm can solve them in an appropriate amount of time. We call these types of problems <em>NP-Complete problems</em> (see Chapter 34).</p><ol><li>No one knows if efficient algorithms exist for NP-complete problems</li><li>If a solution exists for one, a solution exists for all of them</li><li>No NP-complete problem is the same, but they are similar.</li></ol><p>NP-complete problems appear often in everyday solutions.</p><p>We might have access to computers with multiple cores, which allows for <em>&ldquo;Task-Parallelism&rdquo;</em> (see Chapter 26).</p><p>Algorithms that receive input over time, rather than having input present at the start, are called <em>online algorithms</em> (see Chapter 27).</p><h3 id=exercises-11>Exercises 1.1</h3><ol><li>Describe your own real-world example that requires sorting. Describe one that requires finding the shortest distance between two points.</li></ol><p>A quick example: organizing socks (low-cut vs. high-cut).
Distance: when j-walking</p><ol start=2><li>Other than speed, what other measures of efficiency might you need to consider in a real-world setting?</li></ol><p>Legibility: can the algorithm produce output that is easily understandable? Is the algorithm itself readable?</p><ol start=3><li>Select a data structure that you have seen, and discuss it&rsquo;s strengths and limitations.</li></ol><p>A USB Stick:</p><ul><li>Pros: Able to travel easily, holds most files</li><li>Cons: Not large usually (storage wise), easy to wash/lose</li></ul><ol start=4><li>How are the shortest-path and traveling salesperson problems given above similar? How are they different?</li></ol><p>Similarities: Both deal with distance, and need to know/search for their paths before traveling.</p><p>Differences: Shortest-path deals with A - B, while traveling-salesperson has to account for <em>n</em> number of stops, and compare each iteration to find the most efficient.</p><ol start=5><li>Suggest a real-world problem in which only the best solution will do. Then, come up with one in which &ldquo;approximately&rdquo; the best solution is good enough.</li></ol><p>I would say something as inconsequential as perfect or near-perfect, it would come down to a question of scope and overall consequences. Let&rsquo;s take for example, fixing the subway stations here in NYC. The route in which stations are fixed, or sorted, should be intentional. This would facilitate a best-case scenario decision only. However, if there is <strong>no</strong> best case, where everyone is inconvenienced regardless of the route, the near best would be acceptable.</p><ol start=6><li>Suggest a real-world problem in which sometimes the entire input is available before you need to solve a problem, but other times the input is not entirely available in advance and arrives over time.</li></ol><p>Shipping statistics is the first that comes to mind. We know when we place an order, where the order is going, and an approximation that is usually accurate. This isn&rsquo;t always the case however. Unexpected weather conditions always throw off shipping dates.</p><h2 id=12-algorithms-as-a-technology>1.2 Algorithms as a technology</h2><p>If computers were infinitely fast, any method that&rsquo;s correct for solving a problem would do.</p><p>You should choose algorithms that use the resources of time and space efficiently; both are precious.</p><h3 id=efficiency>Efficiency</h3><p>Let&rsquo;s consider two sorting methods:</p><ol><li><strong>Insertion Sort</strong>: takes $C_1n^2$ to sort $n$ items, where $C_1$ is a constant, but we can just say it takes $n^2$</li><li><strong>Merge Sort:</strong> takes $C_2n lg n$, where $lgn$ stands for $log_2 n$ and $C_2$ is another constant</li></ol><p>Insertion sort typically has a smaller constant factor than merge sort, so that $C_1 &lt; C_2$. However, constant factors have far less of an impact on running time than the dependency of the input size.</p><p>We can take the two above and explain their run times as so:</p><ul><li><strong>Insertion:</strong> $C_1<em>n</em>n$</li><li><strong>Merge:</strong> $C_2<em>n</em>lgn$</li></ul><p>For larger numbers, $lgn$ will always return smaller than $n$.</p><p>When $n=1000$, $lgn = 10$. When $n=1000000$, $lgn = 20$.</p><p>Basically, we should be using insertion sort for smaller input sizes, and merge for larger.</p><p>Algorithms should be understood as a technology. Even though technology has advanced to abstraction being the primary objective of most software, everything regardless uses algorithms in some way.</p><p>Having a solid base of algorithmic knowledge and technique is one characteristic of a good programmer.</p><h3 id=exercises-12>Exercises 1.2</h3><ol><li>Give an example of an application that requires algorithmic content at the application level, and discuss the function of the algorithms involved.</li></ol><p>Instagram is a really easy answer. The feed is literally called &ldquo;the algorithm&rdquo;. It&rsquo;s based off many different factors. Said algorithm dictates your engagement to a certain extent.</p><ol start=2><li>Suppose that for inputs of size $n$ on a particular computer, insertion sort runs in $8n^2$ steps and merge sort runs in $64nlogn$ steps. For which values of $n$ does insertion sort beat merge sort?</li></ol><p>We can start by using an example of just 10 instructions, then incrementing up by increasing the exponent by 1 We&rsquo;ll be dividing by $10^7$, our virtual computer that can perform that many tasks per minute. Our answer will be returned in seconds.</p><p>{{ $image := .Resources.Get &ldquo;Insertion_Merge_10.png&rdquo; }}</p><p>Insertion sort is faster, so we keep going. Let&rsquo;s go up to the next interval, $10^2$ instructions.</p><p>{{ $image2 := .Resources.Get &ldquo;Insertion_Merge_10_2.png&rdquo; }}</p><p>So, we see that somewhere between 10 and 100 commands, merge sort begins to beat out insertion. I also tried 50, which Merge sort still beat. I ended up testing until I found out the exact one which is a bit boring so the answer is 27.</p><ol start=3><li>What is the smallest value of $n$ such that an algorithm whose running time is $100n^2$ runs faster than an algorithm whose running time is $2^n$ on the same machine?</li></ol><p>We&rsquo;ll be using the same machine time ($10^7$) and starting at 10 instructions, and incrementing up.</p><p>{{ $image3 := .Resources.Get &ldquo;a_and_b_problem.png&rdquo; }}</p><p>B is faster, but not by so much, so let&rsquo;s only increment up a little, to lets say 15.</p><p>{{ $image4 := .Resources.Get &ldquo;a_and_b_problem_2.png&rdquo; }}</p><p>A is faster! But is this the minimum value? Let&rsquo;s go down one to make sure.</p><p>{{ $image5 := .Resources.Get &ldquo;a_and_b_problem_3.png&rdquo; }}</p><p>Yup, the next lowest has B winning. So the smallest value A can be is 15.</p><hr><p>Next:
<a href=http://localhost:1313/posts/computer-science/introduction-to-algorithms/part-1/introduction-to-algorithms---chapter-2/>Chapter 2</a></p></div></article><hr><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<span class=tag><a href=http://localhost:1313/tags/computerscience/>computerscience</a></span>
<span class=tag><a href=http://localhost:1313/tags/algorithms/>algorithms</a></span>
<span class=tag><a href=http://localhost:1313/tags/textbook/>textbook</a></span></p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
1292 Words</p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2024-07-17 20:00</p></div><div class=pagination><div class=pagination__buttons><span class="button previous"><a href=http://localhost:1313/posts/computer-science/introduction-to-algorithms/part-1/introduction-to-algorithms---chapter-2/><span class=button__icon>←</span>
<span class=button__text>Introduction to Algorithms - Chapter 2</span></a></span></div></div></main></div><footer class=footer></footer></div><script type=text/javascript src=/bundle.min.e89fda0f29b95d33f6f4224dd9e5cf69d84aff3818be2b0d73e731689cc374261b016d17d46f8381962fb4a1577ba3017b1f23509d894f6e66431f988c00889e.js integrity="sha512-6J/aDym5XTP29CJN2eXPadhK/zgYvisNc+cxaJzDdCYbAW0X1G+DgZYvtKFXe6MBex8jUJ2JT25mQx+YjACIng=="></script></body></html>