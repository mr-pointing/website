<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Datastructures on Mr. Pointing</title>
    <link>http://localhost:1313/tags/datastructures/</link>
    <description>Recent content in Datastructures on Mr. Pointing</description>
    <generator>Hugo</generator>
    <language>en</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Mon, 03 Mar 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/datastructures/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Grokking Algorithms - Chapter 8</title>
      <link>http://localhost:1313/notes/computer-science/textbooks/grokking-algorithms/grokking-algorithms---chapter-8/</link>
      <pubDate>Mon, 03 Mar 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/notes/computer-science/textbooks/grokking-algorithms/grokking-algorithms---chapter-8/</guid>
      <description>Balanced Trees From on out, if an array or linked list isn&amp;rsquo;t enough, a tree should be our next structure to try. It&amp;rsquo;s a balancing act to choose between both, especially for run time. Binary Search Trees are great, especially for insertion.&#xA;Remember, arrays take longer to insert than linked lists, but provide faster sorts. Binary Search Trees optimize by providing a clear and easy to understand structure: a root node with values larger to their right, and smaller to the left.</description>
    </item>
    <item>
      <title>Grokking Algorithms - Chapter 7</title>
      <link>http://localhost:1313/notes/computer-science/textbooks/grokking-algorithms/grokking-algorithms---chapter-7/</link>
      <pubDate>Sun, 02 Mar 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/notes/computer-science/textbooks/grokking-algorithms/grokking-algorithms---chapter-7/</guid>
      <description>Trees A subset of graphs, trees are similarly made with nodes and edges and come in multiple different varieties. The first tree we are going to look at is the rooted tree, which is quite easy to visualize.&#xA;Rooted trees must have one node that heads to all other nodes in the tree. Nodes have at most one parent, and the only node with no parent is known as the root node.</description>
    </item>
    <item>
      <title>Grokking Algorithms - Chapter 6</title>
      <link>http://localhost:1313/notes/computer-science/textbooks/grokking-algorithms/grokking-algorithms---chapter-6/</link>
      <pubDate>Fri, 28 Feb 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/notes/computer-science/textbooks/grokking-algorithms/grokking-algorithms---chapter-6/</guid>
      <description>Breadth-First Search Graphs are the next data structure we are going to learn. Breadth-first search is the first graphing algorithm we&amp;rsquo;ll take a look at, and will give us the ability to find the shortest distance between two points.&#xA;There are many use cases for BFS:&#xA;Spell checker Finding nearby doctors/hospitals Search engines Graphs come in many different forms. One of the easiest ways to visualize is with locations:</description>
    </item>
    <item>
      <title>Grokking Algorithms - Chapter 5</title>
      <link>http://localhost:1313/notes/computer-science/textbooks/grokking-algorithms/grokking-algorithms---chapter-5/</link>
      <pubDate>Thu, 27 Feb 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/notes/computer-science/textbooks/grokking-algorithms/grokking-algorithms---chapter-5/</guid>
      <description>Hash Tables Hash tables are the more formal term for Python&amp;rsquo;s Dictionary structure; a key-value pairing of elements. Hash functions are any function that does the mapping of a value to an input.&#xA;Two main rules when implementing hash tables:&#xA;Pairings should be consistent Key&amp;rsquo;s should be unique The way these mappings work are complex, but essentially, when using Python, grabbing values from a dictionary is pretty fast and grants instant access.</description>
    </item>
    <item>
      <title>NumPy Quickstart</title>
      <link>http://localhost:1313/notes/computer-science/python/numpy-notes/numpy-quickstart/</link>
      <pubDate>Mon, 30 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/notes/computer-science/python/numpy-notes/numpy-quickstart/</guid>
      <description>Link to documentation.&#xA;Prerequisites What should you know to get the most out of this lesson? At the very least, the fundamentals of Python. You should also refer to this to get a fundamental understanding of the reasons why we&amp;rsquo;d want to use ndarray in the first place.&#xA;What are we doing this lesson then? We&amp;rsquo;re going to learn about what one, two, and $n$ dimensional arrays actually are, some algebra operations on ndarray objects without for loops, and even more advanced things like what axis and shape properties are.</description>
    </item>
    <item>
      <title>What is NumPy</title>
      <link>http://localhost:1313/notes/computer-science/python/numpy-notes/what-is-numpy/</link>
      <pubDate>Thu, 20 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/notes/computer-science/python/numpy-notes/what-is-numpy/</guid>
      <description>Link to documentation&#xA;What is NumPy? Python lists are great- easy to use, easy to understand, and perfect for quick one-and-done scenarios. However, there is a huge downside to lists. In most cases, since lists can accept any data type by default, this leaves lists open to unexpected data types you might not want around your list data.&#xA;NumPy is a solution to this issue, specifically in the realm of scientific computing.</description>
    </item>
    <item>
      <title>The Python Tutorial Notes - Chapter 5</title>
      <link>http://localhost:1313/notes/computer-science/python/python-tutorial/the-python-tutorial-notes---chapter-5/</link>
      <pubDate>Mon, 10 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/notes/computer-science/python/python-tutorial/the-python-tutorial-notes---chapter-5/</guid>
      <description>Data Structures 6/10/2024&#xA;5.1 More on Lists Methods for Lists:&#xA;list.append(x) Adds an item to the end of the list Equivalent to a[len(a):] = [x] list.extend(iterable) Extend the list by appending all items from an iterable list.insert(i, x) Insert an item into a given position, where i is the index location and x is the value list.remove(x) Remove the first item from the list whose value is equal to x, ValueError if no such item list.</description>
    </item>
  </channel>
</rss>
